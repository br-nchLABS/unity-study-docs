[목차로 돌아가기](./README.md) | [이전: 08-연산자](./08-연산자.md) | [다음: 10-첫2D플랫포머게임만들기](./10-첫2D플랫포머게임만들기.md)

# 09 - 2D 게임을 위한 주요 컴포넌트 살펴보기

이전 시간까지 C# 스크립트의 기본 문법들을 배웠습니다. 이제 Unity 에디터로 돌아와서, 2D 게임을 만드는 데 핵심적인 역할을 하는 **컴포넌트(Components)**들에 대해 자세히 알아볼 시간입니다. 게임 오브젝트는 껍데기일 뿐이고, 바로 이 컴포넌트들이 게임 오브젝트에 생명력을 불어넣어 줍니다.

## 1. 컴포넌트(Component)란 무엇인가? (복습)

다시 한번 기억해봅시다. 컴포넌트는 게임 오브젝트에 붙어서 특정 기능을 수행하는 부품과 같습니다. 예를 들어, 캐릭터가 화면에 보이게 하려면 `Sprite Renderer` 컴포넌트가 필요하고, 물리 법칙에 따라 움직이게 하려면 `Rigidbody 2D` 컴포넌트가 필요합니다.

하나의 게임 오브젝트는 여러 개의 컴포넌트를 가질 수 있습니다. 예를 들어 플레이어 캐릭터는 화면에 보이는 기능(`Sprite Renderer`), 물리적으로 움직이는 기능(`Rigidbody 2D`), 다른 물체와 충돌을 감지하는 기능(`Collider 2D`), 그리고 우리가 만든 플레이어 제어 스크립트까지 모두 가질 수 있는 것입니다.

## 2. 2D 게임의 핵심 컴포넌트 소개

이제 2D 게임을 만들 때 자주 사용하게 될 핵심 컴포넌트들을 하나씩 살펴보겠습니다.

### 가. Transform (트랜스폼)

-   **역할**: 모든 게임 오브젝트가 기본적으로 가지고 있는 컴포넌트로, 해당 오브젝트의 **위치(Position)**, **회전(Rotation)**, **크기(Scale)** 값을 3차원 공간(X, Y, Z) 기준으로 관리합니다. 2D 게임에서는 주로 X, Y 위치와 Z 회전값, 그리고 X, Y 크기 값을 사용하게 될 것입니다. Z 위치는 2D에서 주로 렌더링 순서(앞에 보이게 할지, 뒤에 보이게 할지)를 정할 때 사용하기도 합니다.
-   **주요 속성**:
    -   `Position`: 오브젝트의 X, Y, Z 좌표.
    -   `Rotation`: 오브젝트의 X, Y, Z 축 기준 회전값 (각도).
    -   `Scale`: 오브젝트의 X, Y, Z 축 기준 크기 배율.

### 나. Sprite Renderer (스프라이트 렌더러)

-   **역할**: 2D 이미지, 즉 **스프라이트(Sprite)**를 게임 화면에 그려주는 역할을 합니다. 우리가 보는 2D 캐릭터, 배경, 아이템 등은 모두 이 컴포넌트를 통해 화면에 표시됩니다.
-   **주요 속성**:
    -   `Sprite`: 화면에 표시할 이미지 에셋을 연결하는 곳.
    -   `Color`: 스프라이트의 색상을 변경하거나 투명도를 조절합니다.
    -   `Flip`: `X` 또는 `Y` 축을 기준으로 스프라이트를 뒤집을 수 있습니다 (좌우 반전 등).
    -   `Sorting Layer`: 여러 스프라이트가 겹쳐 있을 때 어떤 레이어에 속한 스프라이트를 먼저 그릴지 순서를 정하는 그룹입니다. (예: Background, Default, Foreground, UI 등)
    -   `Order in Layer`: 같은 `Sorting Layer` 내에서 스프라이트들의 그리기 순서를 정하는 값입니다. 숫자가 클수록 위에 그려집니다.

### 다. Camera (카메라)

-   **역할**: 게임 세계를 플레이어에게 보여주는 눈과 같은 역할을 합니다. 이 카메라가 비추는 영역이 실제 게임 화면에 나타나게 됩니다.
-   **주요 속성 (2D 게임)**:
    -   `Projection`: 카메라의 투영 방식입니다.
        -   `Orthographic`: 2D 게임에서 주로 사용됩니다. 원근감이 없어 모든 오브젝트가 같은 크기로 보입니다.
        -   `Perspective`: 3D 게임에서 주로 사용됩니다. 원근감이 있어 멀리 있는 오브젝트는 작게 보입니다.
    -   `Size`: `Orthographic` 카메라일 때, 카메라가 수직으로 담을 수 있는 화면 높이의 절반 크기입니다. 이 값을 조절하여 화면 확대/축소 효과를 낼 수 있습니다.
    -   `Background`: 카메라가 아무것도 비추지 않을 때 표시되는 배경색입니다.
    -   `Culling Mask`: 특정 레이어에 속한 오브젝트만 카메라에 보이도록 선택적으로 컬링(제외)할 수 있습니다.

### 라. Rigidbody 2D (리지드바디 2D)

-   **역할**: 게임 오브젝트가 Unity의 2D 물리 엔진의 제어를 받도록 만들어줍니다. 즉, 중력의 영향을 받거나, 다른 오브젝트와 물리적으로 충돌하고 반응하게 하려면 이 컴포넌트가 필요합니다.
-   **주요 속성**:
    -   `Body Type`:
        -   `Dynamic`: 물리 효과를 가장 많이 받는 타입입니다. 힘을 받으면 움직이고, 중력의 영향을 받으며, 다른 `Dynamic` 또는 `Kinematic` 오브젝트와 충돌합니다.
        -   `Kinematic`: 물리 효과의 영향을 직접 받지는 않지만, 스크립트를 통해 움직일 수 있고 `Dynamic` 오브젝트와 충돌하여 영향을 줄 수 있습니다. 중력의 영향은 받지 않습니다. (예: 움직이는 발판)
        -   `Static`: 움직이지 않는 물체입니다. 물리 효과의 영향을 받지 않지만 `Dynamic` 오브젝트가 와서 부딪힐 수는 있습니다. (예: 바닥, 벽)
    -   `Material`: 물리 재질(Physics Material 2D)을 연결하여 마찰력(Friction)이나 반발력(Bounciness) 등을 설정할 수 있습니다.
    -   `Collision Detection`: 충돌 감지 정확도 설정입니다. (Continuous가 더 정확하지만 성능 소모가 큽니다)
    -   `Sleeping Mode`: 오브젝트가 거의 움직이지 않을 때 물리 계산을 잠시 멈춰 성능을 아끼는 설정입니다.
    -   `Gravity Scale`: 오브젝트에 적용되는 중력의 크기를 조절합니다. (기본값: 1)

### 마. Collider 2D (콜라이더 2D)

-   **역할**: 게임 오브젝트의 물리적인 형태(충돌 범위)를 정의합니다. `Rigidbody 2D`가 실제로 다른 오브젝트와 충돌하려면 이 `Collider 2D` 컴포넌트가 반드시 함께 있어야 합니다. 눈에 보이지는 않지만, 물리 계산에 사용되는 일종의 경계선이라고 생각하면 됩니다.
-   **종류**: 다양한 모양의 콜라이더가 있습니다. 오브젝트의 실제 모양과 가장 유사한 것을 선택하는 것이 좋습니다.
    -   `Box Collider 2D`: 사각형 모양.
    -   `Circle Collider 2D`: 원형 모양.
    -   `Capsule Collider 2D`: 캡슐(둥근 사각형) 모양.
    -   `Polygon Collider 2D`: 다각형 모양. 점들을 찍어 복잡한 모양을 만들 수 있지만, 성능에는 주의해야 합니다.
    -   `Edge Collider 2D`: 선분들의 집합으로, 주로 바닥이나 벽의 경계선을 만드는 데 사용됩니다.
-   **주요 속성**:
    -   `Is Trigger`: 체크하면 물리적인 충돌 반응은 하지 않고, 다른 콜라이더가 이 영역에 들어오거나 나가는 이벤트만 감지할 수 있게 됩니다. (예: 아이템 획득 영역, 특정 지역 진입 감지 등)
    -   `Material`: `Rigidbody 2D`와 마찬가지로 물리 재질을 설정할 수 있습니다.
    -   `Offset`: 콜라이더의 중심 위치를 게임 오브젝트의 중심으로부터 얼마나 떨어뜨릴지 설정합니다.
    -   `Size` (Box, Capsule), `Radius` (Circle): 콜라이더의 크기입니다.

### 바. Animator (애니메이터)

-   **역할**: 게임 오브젝트의 애니메이션을 제어합니다. 간단한 스프라이트 시트 애니메이션부터 여러 애니메이션 상태(예: 서 있기, 걷기, 점프하기)를 만들고 그 사이의 전환을 관리하는 복잡한 애니메이션까지 가능합니다.
-   **주요 속성**:
    -   `Controller`: 애니메이션 상태와 전환 로직이 담긴 **애니메이터 컨트롤러(Animator Controller)** 에셋을 연결하는 곳입니다.
    -   `Avatar`: (주로 3D에서 사용) 애니메이션을 적용할 캐릭터의 뼈대 정보를 담은 에셋입니다.
    -   `Apply Root Motion`: 애니메이션에 포함된 이동/회전 값을 실제 게임 오브젝트의 트랜스폼에 적용할지 여부입니다.
    -   `Culling Mode`: 애니메이션이 화면에 보이지 않을 때 업데이트를 어떻게 처리할지 설정합니다.

### 사. Audio Source (오디오 소스)

-   **역할**: 게임 씬의 특정 위치에서 사운드(배경음악, 효과음 등)를 재생하는 역할을 합니다.
-   **주요 속성**:
    -   `AudioClip`: 재생할 오디오 파일(에셋)을 연결하는 곳입니다.
    -   `Play On Awake`: 씬이 시작되거나 이 컴포넌트가 활성화될 때 자동으로 오디오를 재생할지 여부입니다.
    -   `Loop`: 오디오 재생이 끝나면 다시 처음부터 반복할지 여부입니다.
    -   `Volume`: 사운드 크기 (0 ~ 1)입니다.
    -   `Pitch`: 사운드 높낮이 (1이 기본값)입니다.
    -   `Spatial Blend`: 2D 사운드(0)와 3D 사운드(1) 사이를 조절합니다. 2D 게임에서는 보통 0으로 설정하여 어디서든 같은 크기로 들리게 합니다.

### 아. Audio Listener (오디오 리스너)

-   **역할**: `Audio Source`에서 나오는 소리를 듣는 귀와 같은 역할을 합니다. 이 컴포넌트가 있는 게임 오브젝트(보통 메인 카메라)를 기준으로 소리가 들리게 됩니다. 씬에 단 하나의 `Audio Listener`만 존재하는 것이 일반적입니다.

### 자. Tilemap Renderer & Tilemap Collider 2D (타일맵 렌더러 & 타일맵 콜라이더 2D)

-   **역할**: 2D 타일 기반의 맵을 만들 때 사용됩니다. 작은 타일 이미지들을 격자(그리드)에 맞춰 배치하여 레벨을 효율적으로 디자인할 수 있게 해줍니다. `Tilemap Renderer`는 타일맵을 화면에 그리고, `Tilemap Collider 2D`는 타일맵에 충돌 기능을 부여합니다.
-   **사용**: `GameObject > 2D Object > Tilemap` 메뉴를 통해 생성할 수 있습니다. `Tile Palette` 창을 이용해 타일을 선택하고 씬에 그릴 수 있습니다.

### 차. Canvas (캔버스) - UI 시스템

-   **역할**: 게임의 사용자 인터페이스(UI) 요소들(예: 점수판, 체력 바, 버튼, 메뉴 등)을 배치하고 화면에 그리는 공간입니다. UI 요소들은 일반 게임 오브젝트와는 다른 방식으로 렌더링되고 관리됩니다.
-   **주요 속성**:
    -   `Render Mode`:
        -   `Screen Space - Overlay`: UI가 항상 화면 가장 위에 그려집니다. 가장 일반적인 방식입니다.
        -   `Screen Space - Camera`: 특정 카메라에 맞춰 UI가 그려지며, 카메라 뷰에 따라 크기나 위치가 변할 수 있습니다. 3D 공간에 UI를 띄우는 효과도 가능합니다.
        -   `World Space`: UI가 일반 게임 오브젝트처럼 씬의 특정 공간에 배치됩니다. (예: 캐릭터 머리 위에 뜨는 체력 바)
    -   `Canvas Scaler (컴포넌트)`: 다양한 화면 해상도에 맞춰 UI 크기를 어떻게 조절할지 정책을 설정합니다.

#### Canvas 하위 UI 컴포넌트 예시:

-   **Image**: 스프라이트 이미지를 UI에 표시합니다. (예: 아이콘, 배경 이미지, 체력 바의 채워진 부분 등)
-   **Text - TextMeshPro**: UI에 텍스트를 표시합니다. Unity의 기본 Text보다 훨씬 강력하고 다양한 스타일을 지원하는 TextMeshPro 사용을 권장합니다. (Window > TextMeshPro > Import TMP Essentials 필요)
-   **Button**: 사용자가 클릭할 수 있는 버튼입니다. 클릭했을 때 특정 동작을 실행하도록 설정할 수 있습니다.

## 3. 컴포넌트 추가 및 수정 방법

게임 오브젝트에 새로운 컴포넌트를 추가하거나 기존 컴포넌트의 값을 수정하는 것은 **인스펙터(Inspector) 창**에서 이루어집니다.

1.  씬이나 하이어라키(Hierarchy) 창에서 컴포넌트를 추가/수정할 게임 오브젝트를 선택합니다.
2.  인스펙터 창에 해당 게임 오브젝트의 정보와 현재 붙어있는 컴포넌트 목록이 나타납니다.
3.  **새 컴포넌트 추가**: 인스펙터 창 하단의 `Add Component` 버튼을 클릭하고, 원하는 컴포넌트를 검색하여 선택하면 됩니다.
4.  **컴포넌트 값 수정**: 각 컴포넌트 영역에 있는 여러 속성 값들을 직접 입력하거나 드롭다운 메뉴에서 선택하여 수정할 수 있습니다.

## 4. 간단한 2D 예시

### 예시 1: 떨어지는 사각형 만들기

1.  씬에 2D 사각형 스프라이트를 하나 만들어봅니다 (`GameObject > 2D Object > Sprites > Square`). 이름을 `FallingSquare`로 변경해줍니다.
2.  `FallingSquare`를 선택하고 인스펙터 창에서 `Add Component`를 눌러 `Rigidbody 2D`를 추가합니다.
3.  다시 `Add Component`를 눌러 `Box Collider 2D`를 추가합니다.
4.  바닥 역할을 할 또 다른 2D 사각형 스프라이트를 만들고 이름을 `Ground`로 합니다. `Ground`의 `Y` 스케일을 조금 늘리고 `Y` 위치를 `FallingSquare`보다 아래로 내려줍니다.
5.  `Ground`를 선택하고 `Add Component`로 `Box Collider 2D`를 추가합니다. (Rigidbody 2D는 추가하지 않아도 됩니다. 움직이지 않는 바닥이니까요!)
6.  게임을 실행(`Play` 버튼)하면 `FallingSquare`가 중력에 의해 아래로 떨어지다가 `Ground`와 충돌하여 멈추는 것을 볼 수 있을 것입니다!

### 예시 2: 간단한 UI 버튼 만들기

1.  씬에 UI 버튼을 만들어봅니다 (`GameObject > UI > Button - TextMeshPro`). 이렇게 하면 `Canvas`와 `EventSystem`도 자동으로 생성될 것입니다.
2.  생성된 `Button`을 선택하고 인스펙터 창을 봅니다. `Button` 컴포넌트의 `On Click ()` 이벤트 리스트가 보일 것입니다.
3.  새로운 C# 스크립트를 만들고 이름은 `UIClickTest`라고 합니다. 다음과 같이 간단한 코드를 작성합니다.
    ```csharp
    using UnityEngine;

    public class UIClickTest : MonoBehaviour
    {
        public void OnMyButtonClick()
        {
            Debug.Log("버튼이 클릭되었습니다!");
        }
    }
    ```
4.  빈 게임 오브젝트를 하나 만들고 (`Create Empty`), 이름을 `UIManager` 등으로 지은 후, 여기에 `UIClickTest` 스크립트를 붙여줍니다.
5.  다시 `Button`을 선택하고 `On Click ()` 리스트의 `+` 버튼을 누릅니다.
6.  새로 생긴 슬롯의 `None (Object)` 부분에 하이어라키 창에서 `UIManager` 게임 오브젝트를 드래그 앤 드롭해줍니다.
7.  `No Function`이라고 되어 있는 드롭다운 메뉴를 클릭하고, `UIClickTest > OnMyButtonClick()`를 선택합니다.
8.  게임을 실행하고 버튼을 클릭하면 Console 창에 "버튼이 클릭되었습니다!" 메시지가 뜨는 것을 볼 수 있습니다.

이처럼 컴포넌트들을 조합하고 스크립트로 제어하면서 게임의 다양한 기능들을 구현해나가는 것입니다. 처음에는 컴포넌트 종류도 많고 속성도 복잡해 보일 수 있지만, 하나씩 직접 사용해보면서 익숙해지는 것이 중요합니다! 겁먹지 말고 이것저것 만져봅시다!

[목차로 돌아가기](./README.md) | [이전: 08-연산자](./08-연산자.md) | [다음: 10-첫2D플랫포머게임만들기](./10-첫2D플랫포머게임만들기.md) 